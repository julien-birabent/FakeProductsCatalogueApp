package com.julienbirabent.fakeproductscatalogue.rx.firebase

import com.google.android.gms.tasks.Task
import com.google.firebase.firestore.*
import com.julienbirabent.fakeproductscatalogue.data.entity.FireStoreAutoGeneratedIdModel
import com.julienbirabent.fakeproductscatalogue.data.entity.Model
import com.julienbirabent.fakeproductscatalogue.data.entity.UniqueModel
import io.reactivex.Observable
import io.reactivex.ObservableEmitter
import io.reactivex.Single
import io.reactivex.SingleEmitter


object RxFireStore {

    fun observeCollection(
        database: FirebaseFirestore,
        collectionPath: String,
        queryBlock: (CollectionReference.() -> Unit) = {}
    ): Observable<QuerySnapshot> {
        return Observable.create { emitter ->
            database.collection(collectionPath)
                .apply(queryBlock)
                .setupObservableEmitter(emitter)

        }
    }

    fun observeDocument(
        database: FirebaseFirestore,
        collectionPath: String,
        documentPath: String,
        queryBlock: (DocumentReference.() -> Unit) = {}
    ): Observable<DocumentSnapshot> {
        return Observable.create { emitter ->
            database.collection(collectionPath).document(documentPath)
                .apply(queryBlock)
                .setupObservableEmitter(emitter)
        }
    }

    private fun DocumentReference.setupObservableEmitter(emitter: ObservableEmitter<DocumentSnapshot>) {
        apply {
            addSnapshotListener { value, exception ->
                value?.let { emitter.onNext(it) }
                if (!emitter.isDisposed) exception?.let { emitter.onError(exception) }
            }.apply { emitter.setCancellable { remove() } }
        }
    }

    private fun CollectionReference.setupObservableEmitter(emitter: ObservableEmitter<QuerySnapshot>) {
        apply {
            addSnapshotListener { value, exception ->
                value?.let { emitter.onNext(it) }
                if (!emitter.isDisposed) exception?.let { emitter.onError(exception) }
            }.apply { emitter.setCancellable { remove() } }
        }
    }

    fun observeDocumentOnce(
        database: FirebaseFirestore,
        collectionPath: String,
        documentPath: String,
        queryBlock: (DocumentReference.() -> Unit) = {}
    ): Single<DocumentSnapshot> {
        return Single.create { emitter ->
            database.collection(collectionPath).document(documentPath)
                .apply(queryBlock).get()
                .setupSingleEmitter(emitter)
        }
    }

    private fun <T> Task<T>.setupSingleEmitter(emitter: SingleEmitter<T>) {
        apply {
            addOnSuccessListener { value ->
                value.let { emitter.onSuccess(value) }
            }.addOnFailureListener {
                if (!emitter.isDisposed) exception?.let { emitter.onError(it) }
            }
        }
    }

    private fun <T> Task<Void>.setupSingleEmitter(emitter: SingleEmitter<T>, onSuccessValue: T) {
        apply {
            addOnSuccessListener {
                emitter.onSuccess(onSuccessValue)
            }.addOnFailureListener {
                if (!emitter.isDisposed) exception?.let { emitter.onError(it) }
            }
        }
    }

    fun <T : Any> addDocument(
        database: FirebaseFirestore,
        collectionPath: String,
        value: T
    ): Single<DocumentReference> {
        return Single.create { e ->
            database.collection(collectionPath)
                .add(value)
                .setupSingleEmitter(e)
        }
    }

    fun <T : Model> setDocument(
        database: FirebaseFirestore,
        collectionPath: String,
        documentId: String,
        value: T
    ): Single<T> {
        return Single.create { e ->
            database.collection(collectionPath).document(documentId)
                .set(value)
                .setupSingleEmitter(emitter = e, onSuccessValue = value)
        }
    }

    fun <T : UniqueModel> setDocument(
        database: FirebaseFirestore,
        collectionPath: String,
        value: T
    ): Single<T> {
        return Single.create { e ->
            database.collection(collectionPath).document(value.uid)
                .set(value)
                .setupSingleEmitter(e, value)
        }
    }

    fun <T : Model> deleteDocument(
        database: FirebaseFirestore,
        collectionPath: String,
        documentPath: String,
        documentToDelete: T
    ): Single<T> {
        return Single.create { e ->
            database.collection(collectionPath).document(documentPath)
                .delete()
                .setupSingleEmitter(e, documentToDelete)
        }
    }
}